import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Observable;
import java.util.Observer;

import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.WindowConstants;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

// Generated by Together

/**
 * An interface to SAAMS: Gate Control Console: Inputs events from gate staff,
 * and displays aircraft and gate information. This class is a controller for
 * the GateInfoDatabase and the AircraftManagementDatabase: sends messages when
 * aircraft dock, have finished disembarking, and are fully emarked and ready to
 * depart. This class also registers as an observer of the GateInfoDatabase and
 * the AircraftManagementDatabase, and is notified whenever any change occurs in
 * those <<model>> elements. See written documentation.
 * 
 * @stereotype boundary/view/controller
 * @url element://model:project::SAAMS/design:view:::id1un8dcko4qme4cko4sw27
 * @url element://model:project::SAAMS/design:view:::id1jkohcko4qme4cko4svww
 * @url element://model:project::SAAMS/design:node:::id1un8dcko4qme4cko4sw27.node61
 */
public class GateConsole extends JFrame implements ActionListener, Observer {
	/**
	 * The GateConsole interface has access to the GateInfoDatabase.
	 * 
	 * @supplierCardinality 1
	 * @clientCardinality 0..*
	 * @label accesses/observes
	 * @directed
	 */
	private GateInfoDatabase gid;

	/**
	 * The GateConsole interface has access to the AircraftManagementDatabase.
	 * 
	 * @supplierCardinality 1
	 * @clientCardinality 0..*
	 * @directed
	 * @label accesses/observes
	 */
	private AircraftManagementDatabase amd;

	/**
	 * This gate's gateNumber - for identifying this gate's information in the
	 * GateInfoDatabase.
	 */
	private int gateNumber;

	private ArrayList<Integer> mCodes;
	private JList<String> managementRecordList;
	private JScrollPane scrollList;

	JButton docked;
	JButton unloaded;

	private JTextField passengerNameTf;
	private JButton addPassenger;

	private JButton closeFlight;

	public GateConsole(GateInfoDatabase gid, AircraftManagementDatabase amd, int gateNumber) {
		this.gid = gid;
		this.amd = amd;
		amd.addObserver(this);
		this.gateNumber = gateNumber;
		mCodes = new ArrayList<Integer>();
		initGUI();
	}

	private void initGUI() {
		int gateTitle = gateNumber +1;
		setTitle("Gate " + gateTitle + " Console");
		setSize(500, 200);
		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		if (this.gateNumber == 0) {
			setLocation(1330, 10);
		} else if (this.gateNumber == 1) {
			setLocation(1330, 210);
		} else {
			setLocation(1330, 410);
		}

		JPanel jpGC = new JPanel();

		managementRecordList = new JList<String>(new DefaultListModel<String>());
		scrollList = new JScrollPane(managementRecordList);
		managementRecordList.setFixedCellWidth(250); // Stops resizing when changing tabs
		managementRecordList.setVisibleRowCount(3); // Only ever one aircraft at gate
		managementRecordList.addListSelectionListener(new ListSelectionListener() {

			@Override
			public void valueChanged(ListSelectionEvent arg0) {
				if (!(managementRecordList.getSelectedIndex() == -1)) {

				}

			}
		});
		jpGC.add(scrollList);
		updateManagementRecordList();

		docked = new JButton("Docked");
		docked.addActionListener(this);
		jpGC.add(docked);

		unloaded = new JButton("Unloaded");
		unloaded.addActionListener(this);
		jpGC.add(unloaded);

		JLabel passengerNameLb = new JLabel("Passenger name: ");
		jpGC.add(passengerNameLb);
		passengerNameTf = new JTextField(15);
		jpGC.add(passengerNameTf);

		addPassenger = new JButton("Add Passenger");
		addPassenger.addActionListener(this);
		jpGC.add(addPassenger);

		closeFlight = new JButton("Close Flight");
		closeFlight.addActionListener(this);
		jpGC.add(closeFlight);

		getContentPane().add(jpGC);
		setVisible(true);
	}

	private void updateManagementRecordList() {
		mCodes.clear();
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.TAXIING)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.UNLOADING)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.READY_CLEAN_AND_MAINT)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.FAULTY_AWAIT_CLEAN)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.OK_AWAIT_CLEAN)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.CLEAN_AWAIT_MAINT)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.AWAIT_REPAIR)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.READY_REFUEL)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.READY_PASSENGERS)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.READY_DEPART)));
		mCodes.addAll(Arrays.asList(amd.getWithStatus(ManagementRecord.AWAITING_TAXI)));

		mCodes = getRecordsForThisGate(mCodes);
		String[] flightCodes = new String[mCodes.size()];
		for (int i = 0; i < flightCodes.length; i++) {
			flightCodes[i] = amd.getFlightCode(mCodes.get(i)) + ": " + amd.getStatusString(mCodes.get(i));
		}
		managementRecordList.setListData(flightCodes);
		// Update size of display
		managementRecordList.updateUI();
	}

	private ArrayList<Integer> getRecordsForThisGate(ArrayList<Integer> mCodes) {
		ArrayList<Integer> forThisGate = new ArrayList<Integer>();
		for (int i = 0; i < mCodes.size(); i++) {
			if (amd.getGateNumber(mCodes.get(i)) == this.gateNumber) {
				forThisGate.add(mCodes.get(i));
			}
		}
		return forThisGate;
	}

	@Override
	public void update(Observable arg0, Object arg1) {
		updateManagementRecordList();
	}

	@Override
	public void actionPerformed(ActionEvent evn) {
		if (evn.getSource() == docked) {
			int index = managementRecordList.getSelectedIndex();
			if (index == -1)
				return; // Do nothing

			if (amd.getStatus(mCodes.get(index)) == ManagementRecord.TAXIING) {
				amd.setStatus(mCodes.get(index), ManagementRecord.UNLOADING);
				gid.docked(gateNumber);

			} else {
				JOptionPane.showMessageDialog(this, "Invalid target for docking");
			}

		}

		if (evn.getSource() == unloaded) {
			int index = managementRecordList.getSelectedIndex();
			if (index == -1)
				return; // Do nothing

			if (amd.getStatus(mCodes.get(index)) == ManagementRecord.UNLOADING) {
				amd.setStatus(mCodes.get(index), ManagementRecord.READY_CLEAN_AND_MAINT);
			} else {
				JOptionPane.showMessageDialog(this, "Invalid target for clean & maintenance");
			}
		}

		if (evn.getSource() == addPassenger) {

			String name = passengerNameTf.getText();
			// Only accept characters a-z and spaces /
			if (name.matches("[a-zA-Z ]+")) {
				PassengerDetails details = new PassengerDetails(name);
				int index = managementRecordList.getSelectedIndex();
				if (index == -1) {
					JOptionPane.showMessageDialog(this, "No flight selected");
				} else {
					if(amd.getStatus(mCodes.get(index)) == ManagementRecord.READY_PASSENGERS){
						boolean max = amd.addPassenger(mCodes.get(index), details);
						if(max)
							JOptionPane.showMessageDialog(this,"Flight at full capacity");						
					}
					else {
						JOptionPane.showMessageDialog(this,"Aircraft not in boarding phase");
					}
				}

			} else {
				JOptionPane.showMessageDialog(this, "Invalid passenger name");
			}
		}
		
		if(evn.getSource() == closeFlight) {
			int index = managementRecordList.getSelectedIndex();
			if(index == -1) {
				JOptionPane.showMessageDialog(this, "No flight selected");
			}
			else {
				int status = amd.getStatus(mCodes.get(index));
				if(status == ManagementRecord.READY_PASSENGERS) {
					amd.setStatus(mCodes.get(index),  ManagementRecord.READY_DEPART);
					gid.departed(gateNumber);
				}
				else {
					JOptionPane.showMessageDialog(this,"Flight not ready to be closed");
				}
			}

		}

	}

}

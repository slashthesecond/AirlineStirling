import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Observable;
import java.util.Observer;

import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.WindowConstants;

// Generated by Together

/**
 * An interface to SAAMS: Gate Control Console: Inputs events from gate staff,
 * and displays aircraft and gate information. This class is a controller for
 * the GateInfoDatabase and the AircraftManagementDatabase: sends messages when
 * aircraft dock, have finished disembarking, and are fully emarked and ready to
 * depart. This class also registers as an observer of the GateInfoDatabase and
 * the AircraftManagementDatabase, and is notified whenever any change occurs in
 * those <<model>> elements. See written documentation.
 *
 * @stereotype boundary/view/controller
 * @url element://model:project::SAAMS/design:view:::id1un8dcko4qme4cko4sw27
 * @url element://model:project::SAAMS/design:view:::id1jkohcko4qme4cko4svww
 * @url element://model:project::SAAMS/design:node:::id1un8dcko4qme4cko4sw27.node61
 */
public class GateConsole extends JFrame implements ActionListener, Observer {
    /**
     * The GateConsole interface has access to the GateInfoDatabase.
     *
     * @supplierCardinality 1
     * @clientCardinality 0..*
     * @label accesses/observes
     * @directed
     */
    private GateInfoDatabase gateInfoDatabase;

    /**
     * The GateConsole interface has access to the AircraftManagementDatabase.
     *
     * @supplierCardinality 1
     * @clientCardinality 0..*
     * @directed
     * @label accesses/observes
     */
    private AircraftManagementDatabase aircraftManagementDatabase;

    /**
     * This gate's gateNumber - for identifying this gate's information in the
     * GateInfoDatabase.
     */
    private int gateNumber;

    private ArrayList<Integer> mCodes;
    private JList<String> managementRecordList;

    private JButton dockedBtn;
    private JButton unloadedBtn;

    private JTextField passengerNameTf;
    private JButton addPassengerBtn;

    private JButton closeFlightBtn;

    public GateConsole(GateInfoDatabase gid, AircraftManagementDatabase amd, int gateNumber) {
        this.gateInfoDatabase = gid;
        this.aircraftManagementDatabase = amd;
        amd.addObserver(this);
        this.gateNumber = gateNumber;
        mCodes = new ArrayList<Integer>();
        initGUI();
    }

    /**
     * Initialize user interface
     */
    private void initGUI() {
        int gateTitle = gateNumber + 1;
        setTitle("Gate " + gateTitle + " Console");
        setSize(500, 200);
        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        //Set location based on what gate console this represents
        if (this.gateNumber == 0) {
            setLocation(1330, 10);
        } else if (this.gateNumber == 1) {
            setLocation(1330, 210);
        } else {
            setLocation(1330, 410);
        }

        JPanel jpGC = new JPanel();

        managementRecordList = new JList<String>(new DefaultListModel<String>());
        JScrollPane scrollList = new JScrollPane(managementRecordList);
        managementRecordList.setFixedCellWidth(250); // Stops resizing when changing tabs
        managementRecordList.setVisibleRowCount(3); // Only ever one aircraft at gate

        jpGC.add(scrollList);
        updateManagementRecordList();

        dockedBtn = new JButton("Docked");
        dockedBtn.addActionListener(this);
        jpGC.add(dockedBtn);

        unloadedBtn = new JButton("Unloaded");
        unloadedBtn.addActionListener(this);
        jpGC.add(unloadedBtn);

        JLabel passengerNameLb = new JLabel("Passenger name: ");
        jpGC.add(passengerNameLb);
        passengerNameTf = new JTextField(15);
        jpGC.add(passengerNameTf);

        addPassengerBtn = new JButton("Add Passenger");
        addPassengerBtn.addActionListener(this);
        jpGC.add(addPassengerBtn);

        closeFlightBtn = new JButton("Close Flight");
        closeFlightBtn.addActionListener(this);
        jpGC.add(closeFlightBtn);

        getContentPane().add(jpGC);
        setVisible(true);
    }

    /**
     * Retrieve all relevant mCodes and update managementRecordList
     */
    private void updateManagementRecordList() {
        mCodes.clear();
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.TAXIING)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.UNLOADING)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.READY_CLEAN_AND_MAINT)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.FAULTY_AWAIT_CLEAN)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.OK_AWAIT_CLEAN)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.CLEAN_AWAIT_MAINT)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.AWAIT_REPAIR)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.READY_REFUEL)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.READY_PASSENGERS)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.READY_DEPART)));
        mCodes.addAll(Arrays.asList(aircraftManagementDatabase.getWithStatus(ManagementRecord.AWAITING_TAXI)));

        mCodes = getRecordsForThisGate(mCodes);
        String[] flightCodes = new String[mCodes.size()];
        for (int i = 0; i < flightCodes.length; i++) {
            flightCodes[i] = aircraftManagementDatabase.getFlightCode(mCodes.get(i)) + ": " + aircraftManagementDatabase.getStatusString(mCodes.get(i));
        }
        managementRecordList.setListData(flightCodes);
        // Update size of display
        managementRecordList.updateUI();
    }

    /**
     * Helper method to ensure each gate console only gets mCodes
     * of the aircraft assigned to its gate
     *
     * @param mCodes
     * @return
     */
    private ArrayList<Integer> getRecordsForThisGate(ArrayList<Integer> mCodes) {
        ArrayList<Integer> forThisGate = new ArrayList<Integer>();
        for (Integer i : mCodes) {
            if (aircraftManagementDatabase.getGateNumber(i) == this.gateNumber) {
                forThisGate.add(i);
            }
        }
        return forThisGate;
    }

    @Override
    public void update(Observable arg0, Object arg1) {
        updateManagementRecordList();
    }

    @Override
    public void actionPerformed(ActionEvent evn) {
        if (evn.getSource() == dockedBtn) {
            docked();
        } else if (evn.getSource() == unloadedBtn) {
            unloaded();
        } else if (evn.getSource() == addPassengerBtn) {
            addPassenger();
        } else if (evn.getSource() == closeFlightBtn) {
            closeFlight();
        }
    }

    private void docked() {
        int index = managementRecordList.getSelectedIndex();
        if (index == -1) {
            JOptionPane.showMessageDialog(this, "Please select an aircraft");
        } else {
            int status = aircraftManagementDatabase.getStatus(mCodes.get(index));
            int mCode = mCodes.get(index);
            if (status == ManagementRecord.TAXIING) {
                aircraftManagementDatabase.setStatus(mCode, ManagementRecord.UNLOADING);
                gateInfoDatabase.docked(gateNumber);

            } else {
                JOptionPane.showMessageDialog(this, "Invalid target for docking");
            }
        }
    }

    private void unloaded() {
        int index = managementRecordList.getSelectedIndex();
        if (index == -1) {
            JOptionPane.showMessageDialog(this, "Please select an aircraft");
        } else {
            int status = aircraftManagementDatabase.getStatus(mCodes.get(index));
            int mCode = mCodes.get(index);
            if (status == ManagementRecord.UNLOADING) {
                aircraftManagementDatabase.setStatus(mCode, ManagementRecord.READY_CLEAN_AND_MAINT);
            } else {
                JOptionPane.showMessageDialog(this, "Invalid target for clean & maintenance");
            }
        }
    }

    private void addPassenger() {
        String name = passengerNameTf.getText();
        // Only accept characters a-z and spaces /
        if (name.matches("[a-zA-Z ]+")) {
            PassengerDetails details = new PassengerDetails(name);
            int index = managementRecordList.getSelectedIndex();
            if (index == -1) {
                JOptionPane.showMessageDialog(this, "No flight selected");
            } else {
                if (aircraftManagementDatabase.getStatus(mCodes.get(index)) == ManagementRecord.READY_PASSENGERS) {
                    boolean max = aircraftManagementDatabase.addPassenger(mCodes.get(index), details);
                    if (max) {
                        JOptionPane.showMessageDialog(this, "Flight at full capacity");
                    } else {
                    	JOptionPane.showMessageDialog(this, "Passenger Added");
                    	passengerNameTf.setText("");
                    }
                } else {
                    JOptionPane.showMessageDialog(this, "Aircraft not in boarding phase");
                }
            }
        } else {
            JOptionPane.showMessageDialog(this, "Invalid passenger name");
        }
    }

    private void closeFlight() {
        int index = managementRecordList.getSelectedIndex();
        if (index == -1) {
            JOptionPane.showMessageDialog(this, "No flight selected");
        } else {
            int status = aircraftManagementDatabase.getStatus(mCodes.get(index));
            if (status == ManagementRecord.READY_PASSENGERS) {
                aircraftManagementDatabase.setStatus(mCodes.get(index), ManagementRecord.READY_DEPART);
            } else {
                JOptionPane.showMessageDialog(this, "Flight not ready to be closed");
            }
        }
    }

}
